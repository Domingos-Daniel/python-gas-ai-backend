#!/usr/bin/env python3
"""
M√≥dulo de integra√ß√£o do scraper com o sistema LLM.
Permite buscas inteligentes nos dados scraped e cita√ß√µes de fontes.
"""

import logging
from typing import List, Dict, Optional, Tuple
from .scraper import AngolaEnergyScraper

logger = logging.getLogger(__name__)


class ScrapedDataManager:
    """
    Gerenciador de dados scraped para integra√ß√£o com LLM.
    Fornece busca inteligente e formata√ß√£o de respostas com cita√ß√µes.
    """

    def __init__(self):
        self.scraper = AngolaEnergyScraper()

    def search_and_format_response(self, question: str, max_results: int = 5) -> Tuple[str, List[Dict]]:
        """
        Busca nos dados scraped e formata resposta inteligente com cita√ß√µes.

        Args:
            question: Pergunta do usu√°rio
            max_results: N√∫mero m√°ximo de resultados

        Returns:
            Tupla com (resposta_formatada, lista_de_fontes)
        """
        try:
            # Busca nos dados scraped
            search_results = self.scraper.search_scraped_data(question, max_results=max_results)

            if not search_results:
                return "N√£o encontrei informa√ß√µes espec√≠ficas sobre esta pergunta nos dados dispon√≠veis.", []

            # An√°lise inteligente da pergunta
            question_lower = question.lower()
            is_general_company_question = self._is_general_company_question(question_lower)
            is_leadership_question = self._is_leadership_question(question_lower)
            target_company = self._extract_target_company(question_lower)

            # Formata resposta baseada no tipo de pergunta
            response_parts = []
            sources = []

            if is_general_company_question and target_company:
                # Resposta estruturada para pergunta geral sobre empresa
                response_parts.append(f"üè¢ **{target_company.upper()} - Ag√™ncia Nacional de Petr√≥leo, G√°s e Biocombust√≠veis**\n")
                response_parts.append("A ANPG √© a entidade reguladora do setor petrol√≠fero angolano, respons√°vel por:\n")
                response_parts.append("‚Ä¢ **Regula√ß√£o** do setor upstream e downstream")
                response_parts.append("‚Ä¢ **Fiscaliza√ß√£o** de concess√µes e contratos")
                response_parts.append("‚Ä¢ **Promo√ß√£o** de investimentos no setor energ√©tico")
                response_parts.append("‚Ä¢ **Monitoramento** da produ√ß√£o petrol√≠fera nacional\n")

                # Adiciona informa√ß√µes espec√≠ficas encontradas
                leadership_info = []
                general_info = []

                for result in search_results:
                    if result['found_in_leadership']:
                        leadership_info.append(result)
                    else:
                        general_info.append(result)

                # Se√ß√£o de lideran√ßa
                if leadership_info:
                    response_parts.append("ÔøΩ **Estrutura Executiva:**")
                    for result in leadership_info[:3]:  # M√°ximo 3 itens de lideran√ßa
                        executives = self._extract_executive_names(result.get('leadership_content', ''))
                        if executives:
                            response_parts.append(f"‚Ä¢ **Executivos identificados:** {', '.join(executives[:3])}")
                        else:
                            # Extrai informa√ß√µes relevantes do t√≠tulo
                            title_info = self._extract_title_info(result['title'])
                            if title_info:
                                response_parts.append(f"‚Ä¢ {title_info}")
                        sources.append({
                            'name': 'ANPG',
                            'url': result['url'],
                            'description': f"P√°gina: {result['title'][:50]}...",
                            'relevance_score': result['relevance_score']
                        })

                # Se√ß√£o de informa√ß√µes gerais
                if general_info:
                    response_parts.append("\nÔøΩ **Atividades Recentes:**")
                    for result in general_info[:2]:  # M√°ximo 2 itens gerais
                        # Extrai informa√ß√µes-chave do snippet
                        key_info = self._extract_key_info(result.get('matched_snippets', []))
                        if key_info:
                            response_parts.append(f"‚Ä¢ {key_info}")
                        sources.append({
                            'name': 'ANPG',
                            'url': result['url'],
                            'description': f"P√°gina: {result['title'][:50]}...",
                            'relevance_score': result['relevance_score']
                        })

            elif is_leadership_question:
                # Resposta focada em lideran√ßa
                response_parts.append("üìä **Informa√ß√µes Executivas Encontradas:**\n")

                for result in search_results[:3]:
                    if result['found_in_leadership']:
                        executives = self._extract_executive_names(result.get('leadership_content', ''))
                        if executives:
                            response_parts.append(f"üë§ **Executivos identificados:** {', '.join(executives[:5])}")
                        else:
                            response_parts.append(f"üìÑ **{result['title']}**")

                        # Adiciona contexto relevante
                        if result['matched_snippets']:
                            for snippet in result['matched_snippets'][:1]:
                                clean_snippet = snippet.replace('...', '').strip()
                                if len(clean_snippet) > 20:
                                    response_parts.append(f"   üí° {clean_snippet[:200]}...")

                        response_parts.append(f"   üîó Fonte: [{result['site'].title()}]({result['url']})\n")

                        sources.append({
                            'name': result['site'].title(),
                            'url': result['url'],
                            'description': f"P√°gina: {result['title']}",
                            'relevance_score': result['relevance_score']
                        })

            else:
                # Resposta gen√©rica
                response_parts.append("üìã **Informa√ß√µes Encontradas:**\n")

                for result in search_results[:3]:
                    response_parts.append(f"üìÑ **{result['title']}**")

                    if result['matched_snippets']:
                        for snippet in result['matched_snippets'][:1]:
                            clean_snippet = snippet.replace('...', '').strip()
                            if len(clean_snippet) > 20:
                                response_parts.append(f"   üí° {clean_snippet[:150]}...")

                    response_parts.append(f"   üîó [{result['site'].title()}]({result['url']})\n")

                    sources.append({
                        'name': result['site'].title(),
                        'url': result['url'],
                        'description': f"P√°gina: {result['title']}",
                        'relevance_score': result['relevance_score']
                    })

            # Junta tudo
            final_response = '\n'.join(response_parts)

            # Adiciona nota sobre atualiza√ß√£o dos dados
            final_response += "\n---\n*Dados atualizados automaticamente dos sites oficiais das empresas angolanas*"

            return final_response, sources

        except Exception as e:
            logger.error(f"Erro na busca de dados scraped: {e}")
            return f"Erro ao consultar dados: {str(e)}", []

    def get_leadership_info_formatted(self, company: Optional[str] = None) -> str:
        """
        Retorna informa√ß√µes de lideran√ßa formatadas.

        Args:
            company: Empresa espec√≠fica (opcional)

        Returns:
            Informa√ß√µes formatadas sobre lideran√ßa
        """
        try:
            leadership_data = self.scraper.get_leadership_info(company)

            if not leadership_data:
                if company:
                    return f"N√£o encontrei informa√ß√µes de lideran√ßa para {company}."
                else:
                    return "N√£o encontrei informa√ß√µes de lideran√ßa dispon√≠veis."

            response_parts = ["üë• **Informa√ß√µes Executivas:**\n"]

            for info in leadership_data:
                response_parts.append(f"üè¢ **{info['company'].upper()}**")
                response_parts.append(f"üìã {info['title']}")

                if info['leadership_content']:
                    # Extrai nomes de executivos do conte√∫do
                    executives = self._extract_executive_names(info['leadership_content'])
                    if executives:
                        response_parts.append("üë§ **Executivos identificados:**")
                        for exec_name in executives[:5]:  # M√°ximo 5 por empresa
                            response_parts.append(f"   ‚Ä¢ {exec_name}")
                    else:
                        # Mostra conte√∫do bruto se n√£o conseguir extrair nomes
                        content_preview = info['leadership_content'][:300]
                        response_parts.append(f"   üí° {content_preview}...")

                response_parts.append(f"   üîó {info['citation']}\n")

            return '\n'.join(response_parts)

        except Exception as e:
            logger.error(f"Erro ao obter informa√ß√µes de lideran√ßa: {e}")
            return f"Erro ao consultar informa√ß√µes de lideran√ßa: {str(e)}"

    def _is_leadership_question(self, question: str) -> bool:
        """Verifica se a pergunta √© sobre lideran√ßa/executivos."""
        leadership_keywords = [
            'pca', 'presidente', 'ceo', 'director', 'executivo', 'conselho',
            'board', 'administra√ß√£o', 'management', 'quem √©', 'quem est√°',
            'quem comanda', 'quem dirige', 'l√≠der', 'lideran√ßa'
        ]
        question_lower = question.lower()
        return any(keyword in question_lower for keyword in leadership_keywords)

    def _is_company_question(self, question: str) -> bool:
        """Verifica se a pergunta √© sobre uma empresa espec√≠fica."""
        company_keywords = [
            'sonangol', 'total', 'azule', 'anpg', 'petroangola',
            'empresa', 'companhia', 'sobre a', 'sobre o', 'me fale sobre',
            'fale sobre', 'o que √©', 'quem √©'
        ]
        question_lower = question.lower()
        return any(keyword in question_lower for keyword in company_keywords)

    def _is_general_company_question(self, question: str) -> bool:
        """Verifica se √© uma pergunta geral sobre uma empresa (n√£o espec√≠fica sobre lideran√ßa)."""
        general_keywords = [
            'me fale sobre', 'fale sobre', 'sobre a', 'sobre o', 'o que √©',
            'quem √©', 'empresa', 'companhia', 'organiza√ß√£o', 'entidade'
        ]
        leadership_keywords = [
            'pca', 'presidente', 'ceo', 'director', 'executivo', 'conselho',
            'quem comanda', 'quem dirige', 'l√≠der', 'lideran√ßa'
        ]

        has_general = any(keyword in question for keyword in general_keywords)
        has_leadership = any(keyword in question for keyword in leadership_keywords)

        return has_general and not has_leadership

    def _extract_target_company(self, question: str) -> Optional[str]:
        """Extrai o nome da empresa alvo da pergunta."""
        companies = {
            'anpg': ['anpg', 'ag√™ncia nacional', 'agencia nacional', 'petr√≥leo', 'petroleo'],
            'sonangol': ['sonangol'],
            'total': ['total', 'totalenergies'],
            'azule': ['azule', 'azul'],
            'petroangola': ['petroangola', 'petro angola']
        }

        for company, keywords in companies.items():
            if any(keyword in question for keyword in keywords):
                return company

        return None

    def _extract_title_info(self, title: str) -> Optional[str]:
        """Extrai informa√ß√µes relevantes do t√≠tulo."""
        title_lower = title.lower()

        # Padr√µes comuns em t√≠tulos da ANPG
        if 'visita' in title_lower:
            return "Realiza√ß√£o de visitas t√©cnicas e institucionais"
        elif 'entrega' in title_lower or 'entregam' in title_lower:
            return "Entrega de projetos sociais e infraestrutura"
        elif 'assinatura' in title_lower or 'contrato' in title_lower:
            return "Formaliza√ß√£o de contratos e acordos"
        elif 'descoberta' in title_lower:
            return "Descobertas de novos reservat√≥rios"
        elif 'produ√ß√£o' in title_lower or 'inicio' in title_lower:
            return "In√≠cios de produ√ß√£o e desenvolvimento de campos"
        elif 'forum' in title_lower or 'confer√™ncia' in title_lower:
            return "Participa√ß√£o em eventos e f√≥runs do setor"

        return None

    def _extract_key_info(self, snippets: List[str]) -> Optional[str]:
        """Extrai informa√ß√µes-chave dos snippets."""
        if not snippets:
            return None

        # Junta todos os snippets e procura por informa√ß√µes relevantes
        combined_text = ' '.join(snippets).lower()

        # Procura por n√∫meros e estat√≠sticas
        import re
        numbers = re.findall(r'\b\d+(?:\.\d+)?\b', combined_text)

        if numbers:
            # Se h√° n√∫meros, pode ser produ√ß√£o, valores, etc.
            return f"Dados quantitativos identificados: {', '.join(numbers[:3])}"

        # Procura por nomes de projetos ou blocos
        project_patterns = [
            r'bloco \d+', r'bloco [IVX]+', r'fpso \w+', r'clov', r'egina',
            r'pazflor', r'dalia', r'girassol', r'jasmim', r'rosa', r'orchid'
        ]

        for pattern in project_patterns:
            matches = re.findall(pattern, combined_text, re.IGNORECASE)
            if matches:
                return f"Projetos mencionados: {', '.join(set(matches[:3]))}"

        # Procura por a√ß√µes ou atividades
        actions = []
        if 'entrega' in combined_text or 'entregam' in combined_text:
            actions.append("entrega de infraestrutura")
        if 'visita' in combined_text:
            actions.append("visitas t√©cnicas")
        if 'contrato' in combined_text or 'assinatura' in combined_text:
            actions.append("formaliza√ß√£o de contratos")
        if 'produ√ß√£o' in combined_text or 'produzir' in combined_text:
            actions.append("atividades de produ√ß√£o")

        if actions:
            return f"Atividades: {', '.join(actions)}"

        return None

    def _extract_executive_names(self, text: str) -> List[str]:
        """
        Extrai nomes de executivos do texto usando padr√µes comuns.

        Args:
            text: Texto para analisar

        Returns:
            Lista de nomes encontrados
        """
        import re

        # Padr√µes para nomes de executivos em portugu√™s
        patterns = [
            r'([A-Z][a-z]+(?:\s+[A-Z][a-z]+)+)',  # Nomes pr√≥prios (2+ palavras)
            r'PCA[^a-zA-Z]*([A-Z][a-z]+\s+[A-Z][a-z]+)',  # PCA Nome Sobrenome
            r'Presidente[^a-zA-Z]*([A-Z][a-z]+\s+[A-Z][a-z]+)',  # Presidente Nome Sobrenome
            r'Director[^a-zA-Z]*([A-Z][a-z]+\s+[A-Z][a-z]+)',  # Director Nome Sobrenome
            r'CEO[^a-zA-Z]*([A-Z][a-z]+\s+[A-Z][a-z]+)',  # CEO Nome Sobrenome
        ]

        names = []
        for pattern in patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            names.extend(matches)

        # Remove duplicatas e filtra nomes v√°lidos (pelo menos 2 palavras)
        unique_names = list(set(names))
        valid_names = [name.strip() for name in unique_names if len(name.split()) >= 2]

        return valid_names[:10]  # M√°ximo 10 nomes


# Inst√¢ncia global do gerenciador
scraped_data_manager = ScrapedDataManager()


def search_scraped_data_for_llm(question: str) -> Tuple[str, List[Dict]]:
    """
    Fun√ß√£o de conveni√™ncia para buscar dados scraped e formatar para LLM.

    Args:
        question: Pergunta do usu√°rio

    Returns:
        Tupla com (resposta_formatada, fontes)
    """
    return scraped_data_manager.search_and_format_response(question)


def get_leadership_info_for_llm(company: Optional[str] = None) -> str:
    """
    Fun√ß√£o de conveni√™ncia para obter informa√ß√µes de lideran√ßa formatadas.

    Args:
        company: Empresa espec√≠fica (opcional)

    Returns:
        Informa√ß√µes formatadas
    """
    return scraped_data_manager.get_leadership_info_formatted(company)